# Diophantine_SysY

> Solving the Diophantine Equation `a ^ x + b = c ^ y` using the SysY language

## ðŸ§© Project Overview

**Diophantine_SysY** is an experimental solver written in the **SysY** language for automatically solving Diophantine equations of the form:

```
a ^ x + b = c ^ y
```

where `a`, `b`, and `c` are known positive integers, satisfying:

- a â‰¥ 2
- b â‰¥ 1
- c â‰¥ 2

SysY is a C-language subset designed for educational use in compiler courses at Peking University, with various restrictions in syntax and semantics. As such, this project uses **Python metaprogramming** to generate `.c` source code in SysY style, which is then compiled using `gcc` (or a student compiler) to produce an executable.

## ðŸ“ Project Structure

```
Diophantine_SysY/
â”œâ”€â”€ meta/                      # Python metaprogramming module for code generation
â”‚   â””â”€â”€ generate.py            # Run with `python -m meta.generate` to produce diophantine.c
â”œâ”€â”€ revalidate/                # Post-validation module (CoLean-based)
â”‚   â””â”€â”€ run.py                 # Run with `python -m revalidate.run` to verify .lean files in all
â”‚   â””â”€â”€ all                    # Generated proof scripts redirected here
â”‚       â””â”€â”€ 1.lean
â”‚       â””â”€â”€ 2.lean
â”œâ”€â”€ diophantine.c              # SysY-style main program source (generated by meta)
â”œâ”€â”€ transcendental_diophantine1.lean  # Lean formalization file (part of outsourced proof logic)
â””â”€â”€ README.md
```

## ðŸš€ Compilation & Usage

1. Generate the SysY source code:

```bash
python -m meta.generate
```

2. Compile the generated `diophantine.c` file:
   (To use a student compiler instead, set `for_course_compiler = True` in `meta/generate.py`.)

```bash
gcc diophantine.c -o diophantine
```

3. Run the program:
   (You may also run it via QEMU or other simulation tools.)

```bash
./diophantine
```

### Mode Selection

When running `./diophantine`, **the program does not display prompts**.
You must manually enter a number to select a mode:

- **Enter `0`: Help Mode**
  Displays an overview of all available features â€” recommended for first-time users.

- **Enter `1`: Interactive Mode (recommended)**
  Manually input three integers: `a`, `b`, and `c`.
  The program will attempt to solve the equation `a ^ x + b = c ^ y` for positive integer solutions.
  If successful, the solution and corresponding Lean4 proof code will be printed.

- **Enter `2`: Silent Mode (for research)**
  Input six integers: `a_max a_min b_max b_min c_max c_min`.
  The program will iterate over all non-trivial `(a, b, c)` combinations within the specified ranges and perform batch solving.

- **Enter `3`: Documentation Mode**
  Prints the entire Lean4 formal document `transcendental_diophantine1.lean`.
  **It is strongly recommended to redirect the output to a file**, as the document is very large and may exceed terminal buffer limits.

## ðŸ’¡ Example1: Representative Diophantine Equations

**Note:** All Lean4 code examples below are based on the following `Claim Structure`.

```Lean
-- Claim Structure
structure VerifiedFact where
  prop : Prop
  proof : prop

axiom Claim (prop_to_claim : Prop)
  (verified_facts : List VerifiedFact)
  (revalidator : String)
  : prop_to_claim
```

1. $5 ^ x + 3 = 2 ^ y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 3)\ or\ (x,y)=(3, 7)$

```Lean
/-
(Class II, Front Mode, with magic prime 257)   5 ^ x + 3 = 2 ^ y
For positive integers x, y satisfying 5 ^ x + 3 = 2 ^ y,
if y >= 8, 5 ^ x = 253 (mod 256).
So x = 35 (mod 64),
which implies x = 35, 99, 163, 227 (mod 256).
Therefore, 5 ^ x = 14, 224, 243, 33 (mod 257).
So 2 ^ y = 17, 227, 246, 36 (mod 257), but this is impossible.
Therefore, y < 8.
Further examination shows that (x, y) = (1, 3), (3, 7).
-/
theorem diophantine1_5_3_2 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 5 ^ x + 3 = 2 ^ y) :
  List.Mem (x, y) [(1, 3), (3, 7)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : y >= 8
  have h7 := Claim (2 ^ y % 256 = 0) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 5 ^ x % 256 = 253 := by omega
  have h9 := Claim (x % 64 = 35) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := 5 ^ x % 256 = 253, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (5 ^ x % 257) [14, 224, 243, 33]) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := x % 64 = 35, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (2 ^ y % 257) [17, 227, 246, 36]) [
    {prop := List.Mem (5 ^ x % 257) [14, 224, 243, 33], proof := h10},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
  ] "compute_mod_add"
  have h12 := Claim False [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := List.Mem (2 ^ y % 257) [17, 227, 246, 36], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : y <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 3), (3, 7)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
    {prop := y <= 7, proof := h7},
  ] "diophantine1_back_enumeration"
  exact h8
```

2. $3 ^ x + 10 = 13 ^ y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 1)\ or\ (x,y)=(7, 3)$

```Lean
/-
(Class II, Back Mode, with magic prime 17497)   3 ^ x + 10 = 13 ^ y
For positive integers x, y satisfying 3 ^ x + 10 = 13 ^ y,
if x >= 8, 13 ^ y = 10 (mod 6561).
So y = 1461 (mod 2187),
which implies y = 1461, 3648, 5835, 8022 (mod 8748).
Therefore, 13 ^ y = 11616, 6486, 5881, 11011 (mod 17497).
So 3 ^ x = 11606, 6476, 5871, 11001 (mod 17497), but this is impossible.
Therefore, x < 8.
Further examination shows that (x, y) = (1, 1), (7, 3).
-/
theorem diophantine1_3_10_13 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 3 ^ x + 10 = 13 ^ y) :
  List.Mem (x, y) [(1, 1), (7, 3)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 8
  have h7 := Claim (3 ^ x % 6561 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 13 ^ y % 6561 = 10 := by omega
  have h9 := Claim (y % 2187 = 1461) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 13 ^ y % 6561 = 10, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 2187 = 1461, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001]) [
    {prop := List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011], proof := h10},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 1), (7, 3)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
    {prop := x <= 7, proof := h7},
  ] "diophantine1_front_enumeration"
  exact h8
```

3. $2 ^ x + 89 = 91 ^ y,\ x,y\in\mathbb{N}^*\Rightarrow(x,y)=(1, 1)\ or\ (x,y)=(13, 2)$

```Lean
/-
(Class II, Front Mode, with magic prime 2647)   2 ^ x + 89 = 91 ^ y
For positive integers x, y satisfying 2 ^ x + 89 = 91 ^ y,
if y >= 3, 2 ^ x = 254 (mod 343).
So x = 76 (mod 147),
which implies x = 76, 223, 370, 517, 664, 811, 958, 1105, 1252 (mod 1323).
Therefore, 2 ^ x = 1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970 (mod 2647).
So 91 ^ y = 2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059 (mod 2647), but this is impossible.
Therefore, y < 3.
Further examination shows that (x, y) = (1, 1), (13, 2).
-/
theorem diophantine1_2_89_91 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 2 ^ x + 89 = 91 ^ y) :
  List.Mem (x, y) [(1, 1), (13, 2)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : y >= 3
  have h7 := Claim (91 ^ y % 343 = 0) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 3, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 2 ^ x % 343 = 254 := by omega
  have h9 := Claim (x % 147 = 76) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := 2 ^ x % 343 = 254, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (2 ^ x % 2647) [1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970]) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := x % 147 = 76, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (91 ^ y % 2647) [2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059]) [
    {prop := List.Mem (2 ^ x % 2647) [1994, 852, 1811, 957, 1447, 1513, 2343, 348, 1970], proof := h10},
    {prop := 2 ^ x + 89 = 91 ^ y, proof := h3},
  ] "compute_mod_add"
  have h12 := Claim False [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := List.Mem (91 ^ y % 2647) [2083, 941, 1900, 1046, 1536, 1602, 2432, 437, 2059], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : y <= 2 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 1), (13, 2)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 2 ^ x + 89 = 91 ^ y, proof := h3},
    {prop := y <= 2, proof := h7},
  ] "diophantine1_back_enumeration"
  exact h8
```

4. $x,y\in\mathbb{N}^*\Rightarrow 101^x+3\neq103^y$

```Lean
/-
(Class II, Back Mode, with magic prime 701)   101 ^ x + 3 = 103 ^ y
For positive integers x, y satisfying 101 ^ x + 3 = 103 ^ y,
if x >= 1, 103 ^ y = 3 (mod 101).
So y = 69 (mod 100),
which implies y = 19 (mod 25).
Therefore, 103 ^ y = 583 (mod 701).
So 101 ^ x = 580 (mod 701), but this is impossible.
Therefore, x < 1.
So 101 ^ x + 3 = 103 ^ y is impossible.
-/
theorem diophantine1_101_3_103 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 101 ^ x + 3 = 103 ^ y) :
  False
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 1
  have h7 := Claim (101 ^ x % 101 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 103 ^ y % 101 = 3 := by omega
  have h9 := Claim (y % 100 = 69) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 103 ^ y % 101 = 3, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (103 ^ y % 701) [583]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 100 = 69, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (101 ^ x % 701) [580]) [
    {prop := List.Mem (103 ^ y % 701) [583], proof := h10},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (101 ^ x % 701) [580], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 0 := by omega
  have h8 := Claim False [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
    {prop := x <= 0, proof := h7},
  ] "diophantine1_front_enumeration"
  exact h8
```

## ðŸ§ª Example2: Research Mode + Revalidation

The `.lean` files generated by this program are not fully verified in Lean itself.
Instead, they rely on the **CoLean** framework for **post-hoc structural verification**.
We recommend the following workflow:

```bash
# Step 1: Run the solver and redirect output to Lean4 file
./diophantine > revalidate/all/1.lean
# Suggested input:
2 50 2 100 1 100 2
```

```bash
# Step 2: Revalidate using CoLean
python -m revalidate.run
```

This process performs static structural checks on the generated `.lean` file, helping confirm the validity of the `Claim` structure and triggering additional verification logic as needed.
