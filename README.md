# Diophantine Equation Solver in SysY

An experimental solver for Diophantine equations of the form $a^x + b = c^y$.

This project provides a C program, generated via Python metaprogramming, to solve for positive integer solutions $(x, y)$. The solver is written in **SysY**, a restricted subset of C used for compiler courses.

For the theoretical background and methodology, please refer to our paper: [**An Effective Method for Solving a Class of Transcendental Diophantine Equations**](https://arxiv.org/abs/2510.11753)

## âœ¨ Features

- **Equation Solver**: Finds positive integer solutions for $a^x + b = c^y$.
- **Code Generation**: Uses Python to generate SysY-compliant C code.
- **Formal Proof Generation**: Automatically produces proof scripts in Lean 4 for each solution found.
- **Interactive & Batch Modes**: Supports both single-equation solving and batch processing over ranges of coefficients.
- **Proof Revalidation**: Includes a framework using **CoLean** for post-hoc structural verification of the generated proofs.

## ðŸš€ Getting Started

### Prerequisites

- A C compiler like **GCC**.
- The **GMP** library (GNU Multiple Precision Arithmetic Library) for handling large numbers.
  - On Debian/Ubuntu: `sudo apt-get install libgmp-dev`
  - On macOS (with Homebrew): `brew install gmp`
  - On Windows (with MSYS2): `pacman -S mingw-w64-x86_64-gmp`
- **Python 3.x**.

### Installation & Compilation

1.  **Clone the repository:**

    ```bash
    git clone https://github.com/parkcai/Diophantine.git
    cd Diophantine
    ```

2.  **Generate the C source file:**
    The main C file (`diophantine.c`) is generated by a Python script.

    ```bash
    python -m meta.generate
    ```

    > **Note:** To generate code compatible with a simplified course compiler, set `is_toy = True` in `meta/generate.py`.

3.  **Compile the generated code:**

    ```bash
    gcc -O3 diophantine.c -o diophantine -lgmp
    ```

## ðŸ“– Usage

Run the compiled program from your terminal:

```bash
./diophantine
```

The program starts without a prompt. Enter a number to select an operation mode.

- **`0` â€” Help Mode**: Displays an overview of all features. Recommended for first-time use.

- **`1` â€” Interactive Mode (Recommended)**: You will be asked to input three integers, `a`, `b`, and `c`. The program will then solve $a^x + b = c^y$ and print any solutions along with their Lean 4 proof scripts.

- **`2` â€” Silent Mode (for Research)**: Input six integers representing ranges for the coefficients: `a_max a_min b_max b_min c_max c_min`. The solver will iterate through all combinations and perform batch solving.

- **`3` â€” Documentation Mode**: Prints the full content of the formal Lean 4 document `transcendental_diophantine1.lean`. It's highly recommended to redirect the output to a file:

  ```bash
  ./diophantine > transcendental_diophantine1.lean
  ```

## ðŸ§ª Examples & Proofs

The solver generates a human-readable proof sketch followed by formal Lean 4 code. Here are a few examples of equations and their generated proofs.

Example 1: Solving $5^x + 3 = 2^y$

The program finds two solutions: $(x,y)=(1, 3)$ and $(x,y)=(3, 7)$.

**Proof Sketch:**

> For positive integers $x, y$ satisfying $5^x + 3 = 2^y$, if $y \ge 8$, then $5^x \equiv 253 \pmod{256}$. This implies $x \equiv 35 \pmod{64}$. Checking this modulo 257, we find that $2^y \pmod{257}$ must be in a set of values that is impossible for an integer power of 2. Therefore, $y < 8$. A final check of small values confirms the solutions.

**Generated Lean 4 Code:**

```lean
theorem diophantine1_5_3_2 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 5 ^ x + 3 = 2 ^ y) :
  List.Mem (x, y) [(1, 3), (3, 7)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : y >= 8
  have h7 := Claim (2 ^ y % 256 = 0) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 5 ^ x % 256 = 253 := by omega
  have h9 := Claim (x % 64 = 35) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := 5 ^ x % 256 = 253, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (5 ^ x % 257) [14, 224, 243, 33]) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := x % 64 = 35, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (2 ^ y % 257) [17, 227, 246, 36]) [
    {prop := List.Mem (5 ^ x % 257) [14, 224, 243, 33], proof := h10},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
  ] "compute_mod_add"
  have h12 := Claim False [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := List.Mem (2 ^ y % 257) [17, 227, 246, 36], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : y <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 3), (3, 7)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 5 ^ x + 3 = 2 ^ y, proof := h3},
    {prop := y <= 7, proof := h7},
  ] "diophantine1_back_enumeration"
  exact h8
```

Example 2: Solving $3^x + 10 = 13^y$

The program finds two solutions: $(x,y)=(1, 1)$ and $(x,y)=(7, 3)$.

**Proof Sketch:**

> For positive integers $x, y$ satisfying $3^x + 10 = 13^y$, if $x \ge 8$, then $13^y \equiv 10 \pmod{6561}$. This implies $y \equiv 1461 \pmod{2187}$. Checking this modulo 17497 leads to a contradiction. Therefore, $x < 8$. A final check of small values confirms the solutions.

**Generated Lean 4 Code:**

```lean
theorem diophantine1_3_10_13 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 3 ^ x + 10 = 13 ^ y) :
  List.Mem (x, y) [(1, 1), (7, 3)]
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 8
  have h7 := Claim (3 ^ x % 6561 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 8, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 13 ^ y % 6561 = 10 := by omega
  have h9 := Claim (y % 2187 = 1461) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 13 ^ y % 6561 = 10, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 2187 = 1461, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001]) [
    {prop := List.Mem (13 ^ y % 17497) [11616, 6486, 5881, 11011], proof := h10},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (3 ^ x % 17497) [11606, 6476, 5871, 11001], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 7 := by omega
  have h8 := Claim (List.Mem (x, y) [(1, 1), (7, 3)]) [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 3 ^ x + 10 = 13 ^ y, proof := h3},
    {prop := x <= 7, proof := h7},
  ] "diophantine1_front_enumeration"
  exact h8
```

Example 3: Showing No Solutions for $101^x + 3 = 103^y$

The program proves that no positive integer solutions exist.

**Proof Sketch:**

> For positive integers $x, y$ satisfying $101^x + 3 = 103^y$, if $x \ge 1$, then $103^y \equiv 3 \pmod{101}$. This implies $y \equiv 69 \pmod{100}$. Checking this modulo 701 leads to a contradiction, as $101^x$ would have to be congruent to a value that is not in its cycle modulo 701. Therefore, no solutions exist.

**Generated Lean 4 Code:**

```lean
theorem diophantine1_101_3_103 (x : Nat) (y : Nat) (h1 : x >= 1) (h2 : y >= 1) (h3 : 101 ^ x + 3 = 103 ^ y) :
  False
  := by
  have h4 : x % 1 = 0 := by omega
  have h5 : y % 1 = 0 := by omega
  by_cases h6 : x >= 1
  have h7 := Claim (101 ^ x % 101 = 0) [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h6},
  ] "pow_mod_eq_zero"
  have h8 : 103 ^ y % 101 = 3 := by omega
  have h9 := Claim (y % 100 = 69) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := 103 ^ y % 101 = 3, proof := h8},
  ] "observe_mod_cycle"
  have h10 := Claim (List.Mem (103 ^ y % 701) [583]) [
    {prop := y % 1 = 0, proof := h5},
    {prop := y >= 1, proof := h2},
    {prop := y % 100 = 69, proof := h9},
  ] "utilize_mod_cycle"
  have h11 := Claim (List.Mem (101 ^ x % 701) [580]) [
    {prop := List.Mem (103 ^ y % 701) [583], proof := h10},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
  ] "compute_mod_sub"
  have h12 := Claim False [
    {prop := x % 1 = 0, proof := h4},
    {prop := x >= 1, proof := h1},
    {prop := List.Mem (101 ^ x % 701) [580], proof := h11},
  ] "exhaust_mod_cycle"
  apply False.elim h12
  have h7 : x <= 0 := by omega
  have h8 := Claim False [
    {prop :=  x % 1 = 0, proof := h4},
    {prop :=  x >= 1, proof := h1},
    {prop :=  y % 1 = 0, proof := h5},
    {prop :=  y >= 1, proof := h2},
    {prop := 101 ^ x + 3 = 103 ^ y, proof := h3},
    {prop := x <= 0, proof := h7},
  ] "diophantine1_front_enumeration"
  exact h8
```

## ðŸ”¬ Proof Revalidation Workflow

The generated `.lean` files are not self-contained proofs; they rely on an `axiom` named `Claim`. We provide a Python-based script using the **CoLean** framework to perform post-hoc structural verification.

Here is the recommended workflow:

1.  **Run the solver and save the output**:
    Use Silent Mode to generate a proof and redirect the output to a `.lean` file.

    ```bash
    # Run the solver with input "2 50 2 100 1 100 2"
    ./diophantine > revalidate/all/1.lean
    ```

2.  **Run the revalidation script**:
    This script will parse the generated file, check the structure of all `Claim` calls, and perform additional checks.

    ```bash
    python -m revalidate.run
    ```

## ðŸ“‚ Project Structure

```
Diophantine/
â”œâ”€â”€ meta/                           # Python metaprogramming module for code generation.
â”‚   â”œâ”€â”€ solver/                     # Core logic for solving equations and generating proofs.
â”‚   â”œâ”€â”€ big_int/                    # SysY code generation for large number arithmetic.
â”‚   â”œâ”€â”€ math/                       # Number theory helper functions.
â”‚   â”œâ”€â”€ SysY/                       # Primitives for generating SysY-compliant code.
â”‚   â””â”€â”€ generate.py                 # Main script to run: generates diophantine.c.
â”‚
â”œâ”€â”€ scripts/                        # Utility scripts for running experiments and analysis.
â”‚   â”œâ”€â”€ run_diophantine.py          # Example script to automate running the solver.
â”‚   â””â”€â”€ revalidate_results.py       # Script for post-hoc proof validation.
â”‚
â”œâ”€â”€ diophantine.c                    # The main C source file (auto-generated by meta/generate.py).
â”œâ”€â”€ diophantine.exe                  # The final compiled solver program.
â”œâ”€â”€ transcendental_diophantine1.lean # Demo Lean formalization file.
â””â”€â”€ README.md
```

## ðŸ“œ Citation

If you use this work in your research, please cite our paper:

```bibtex
@article{Diophantine2025,
  title   = {An Effective Method for Solving a Class of Transcendental Diophantine Equations},
  author  = {Zeyu Cai},
  journal = {arXiv preprint arXiv:2510.11753},
  year    = {2025}
}
```
